<Component id="fontModal" src="modal.html" visible="false"></Component>

<script>
    this.fail = false;
    var self = this;
    try {
        /*
        var a = await fetch("/ping",{method:"POST"});
        if(a.status==404) {
            this.fail = true;
            self.props.fail();
        }
        */
    } catch(e) {
        this.fail = true;
        self.props.fail();
    }

    this.refresh_list = new Promise((resolve,reject)=>{
        Import({url:"/list",method:"GET"})
        .done((data)=>{
            //alert(data);
            var json = JSON.parse(data);
            resolve(json);
            
        })
        .send();
    });


    function genId(schema,size) {
        if(!schema) {
            schema = "";
        }
        var code = 'xxxxxxxxxxxxxxxx';
        if(size) {
            var sb = [];
            for(var x = 0; x < size;x++) {
                sb.push("x");
            }
            code = sb.join("");
        }
        return schema+(code).replace(/[x]/g, function(c) {
            var r = Math.random() * 16 | 0;
            if( c == 'x' ) {
                return r.toString(16);
            } else {
                return c;
            }
        });
    }
    this.genId = genId;

</script>
<style>
    body {
        margin:0px;
    }
</style>

<div style="display:flex;background-color:navy;color:white;padding:10px;">
    <div>🧊 NumberCooler Recorder Premium</div>
</div>
<div id="main" style="display:flex;padding:0px;border-left:solid 10px navy;border-right:solid 10px navy;">
    <div id="listPanel" style="flex:0.4;overflow:auto;">
        <div id="listPanelMock"></div>
        <div style="background-color:navy;color:white;">Offline Storage (IndexedDB)</div>
        <div>
            <div id="lblUpload" style="cursor:pointer;">Upload from Disk</div>
            <div id="panelUpload" style="padding-left:20px;display:none;">
                <div>Filename</div>
                <div><input id="txtUploadFilename" type="text"/></div>
                <div>Description</div>
                <div><textarea id="txtUploadDescription" type="text"></textarea></div>
                <div><input id="fileUpload" type="file"/></div>
                <div><button id="btnUpload">upload</button></div>
            </div>
        </div>
        <table border="1" width="100%" cellpadding="0" cellspacing="0">
            
            <Component id="list"></Component>
        </table>
        <Component id="message"></Component>
        <div style="height:40px;"></div>
    </div>
    <div style="width:5px;background-color:navy;"></div>
    <div id="mainPanel" style="flex:1;padding:20px;overflow:auto;">
        <ul>
            <li>stream channel admin : transitions, queue(each item on queue is a keyframe) aka keyframe manager, schedule, script and priorities, place buttons that trigger scripts at recording time with mouse tracking the click. maybe on premium2.</li>
            <li>db (add full text search, including video text and link to that point in video)</li>    
            <li>positioning layers with mouse (snaped)</li>
            <li>selected layer keyboard:</li>
            <ul>
                <li>positioning layer ->(left,right,up,down)</li>
                <li>sizing layer(+/- vertical, +/- horizontal)</li>
                <li>setting layer grid (+/- vertical, +/- horizontal)</li>
            </ul>
        </ul>
        <div id="lblOutputSettings" style="cursor:pointer;">🔧 Settings</div>
        <div id="panelOutputSettings">
            <div style="padding-left:20px;">Output</div>
                <div style="padding-left:20px;">
                    <div style="padding-left:20px;">
                        <div>📺 Video</div>
                        <div style="padding-left:20px;">
                            <div>Resolution</div>
                            <div style="padding-left:20px;">
                                <div style="display:flex;">
                                    <div style="width:150px;border-right:solid 1px #000;padding-right:10px;">
                                        <div style="display:flex;">
                                            <div style="flex:1;">width</div><div><input id="screenWidth" type="text" value="320" style="width:50px;"/></div>
                                        </div>
                                        <div style="display:flex;">
                                            <div style="flex:1;">height</div><div><input id="screenHeight" type="text" value="240" style="width:50px;"/></div>
                                        </div>
                                    </div>
                                    <div style="font-weight:bold;font-size:10px;padding-left:10px;">
                                        <div>(4:3)</div>
                                        <div style="display:flex;padding-left:10px;">
                                            <div id="btnResQVGA" style="margin-right:10px;">QVGA</div>
                                            <div id="btnResVGA" style="margin-right:10px;">VGA</div>
                                            <div id="btnResSVGA" style="margin-right:10px;">SVGA</div>
                                            <div id="btnResXGA" style="margin-right:10px;">XGA</div>
                                        </div>
                                        <div>(16:9)</div>
                                        <div style="display:flex;padding-left:10px;">
                                            <div id="btnResFWVGA" style="margin-right:10px;">FWVGA</div>
                                            <div id="btnResHD720" style="margin-right:10px;">HD 720</div>
                                            <div id="btnResHD1080" style="margin-right:10px;">HD 1080</div>
                                        </div>
                                        <div>(custom)</div>
                                        <div style="display:flex;padding-left:10px;">
                                            <div id="btnResTwitter1" style="margin-right:10px;">Twitter Post</div>
                                            <div id="btnResFacebook1" style="margin-right:10px;">Facebook Post</div>
                                            <div id="btnResFacebook2" style="margin-right:10px;">Facebook Comment</div>
                                        </div>

                                    </div>
                                </div>
                            </div>
                            <button id="btnNewDisplay">new display</button>
                        </div>

                    </div>

                </div>
            
            
        </div>



        <div>🎬 Scene Stack (layer channel)</div>
        

            <div style="padding:5px;display:flex;">

            </div>
            <div style="padding:5px;border:solid 1px #000;display:flex;">
                <div style="flex:1;">
                    <div style="display:flex;">
                        <div><button  id="btnFrontLayerChannel">pull to front</button></div>
                        <div><button  id="btnBackLayerChannel">push to back</button></div>
                        <div style="flex:1;"></div>
                        <div><button  id="btnLayerChannelSaveAll">save all</button></div>

                    </div>
                    <Component id="layerChannelList"></Component>
                    <div><button  id="btnRemoveLayerChannel">remove</button></div>
                </div>
                <div style="flex:1;">
                    <div style="display:flex;">
                        <div><input id="txtLayerChannelName" type="text"/></div><div><button  id="btnAddLayerChannel">add</button></div>
                    </div>
                    <div>grid <input id="txtLayerChannelGrid" type="text" value="[3,3]"/></div>
                    <div>pos <input id="txtLayerChannelPos" type="text" value="[2,2]"/></div>
                    <div>size <input id="txtLayerChannelSize" type="text" value="[1,1]"/></div>
                    <div id="dialogFont">🔤</div>
                </div>
            </div>
        <div id="lblInputSettings" style="cursor:pointer;">🔧 Toolbar</div>
        <div id="panelInputSettings">
            <div style="padding-left:20px;">Input</div>
            <div style="padding-left:20px;">
                <div style="padding-left:20px;display:flex;">
                    
                    <div>
                        <div>🔊 Audio</div>
                        <div style="padding-left:20px;">
                            <div>
                                none
                                <button id="btnSetAudioNone">set</button>
                            </div>
                            <div>
                                microphone
                                <select id="mic_devices"></select>
                                <button id="btnAddMic">add</button>
                            </div>
                            <div>
                                audio file
                                <input id="fileAudio" type="file" multiple="true"/>
                                <button id="btnAddAudioFile">add</button>
                            </div>
                        </div>
                    </div>
                    <div>
                        <div>📺 Video</div>
                        <div style="padding-left:20px;">
                            <div>
                                none
                                <button id="btnSetVideoNone">set</button>
                            </div>
                            <div>
                                screen
                                <button id="btnAddScreen">add</button>
                            </div>
                            <div>
                                camera
                                <select id="video_devices"></select>
                                <button id="btnAddCamera">add</button>
                            </div>
                            <div>
                                image/video file
                                <input id="fileImage" type="file" multiple="true"/>
                                <button id="btnAddImageVideoFile">add</button>
                            </div>
                            <div>
                                text
                                <button id="btnAddText">add</button>
                            </div>
                            <div>
                                html
                                <button id="btnAddHtml">add</button>
                            </div>
                            <div>
                                recorder tab
                                <select id="selRecorderTab"></select>
                                <button id="btnAddRecorderTab">add</button>
                            </div>
                        </div>
                    </div>
                    <div style="height:40px;"></div>
                </div>
            </div>
        </div>

        
        <div>🎬 Stage</div>
        <div style="display:flex;">
            <button id="btnRecord">start recording</button>
            <button id="btnPlay">play</button>
            <button id="btnClearStage">clear</button>
            <input id="chkExportOutput" type="checkbox" checked/>export
            <div style="flex:1;"></div>
            <button id="btnDownloadPicture">download snapshot</button>
            <button id="btnDownloadMovie">download record</button>
        </div>
        
        <div style="padding-left:20px;">
            <div id="lblTracks" style="display:none;">
                <div>🛵 Tracks</div>
                <div>
                    <Component id="tracksView"></Component>
                </div>
            </div>
        </div>
        
        <div id="mockHolder"></div>
        <div id="recordHolder">
            <Component id="mic_holder"></Component>
            <Component id="mic_holder2"></Component>
            <Component id="camera_holder"></Component>
        </div>
        <div id="playholder" style="display:none;">
            <div>🔵 Last Record</div>
            <video id="playscreen"></video>
            <Component id="playaudio"></Component>
        </div>
        <div style="padding:10px;border:solid 1px #000;">
            Filename:<br/><input id="txtSaveFileName" type="text"/><button id="btnSaveFilenameGenerate">generate</button><br/>
            Description:<br/><textarea id="txtSaveDescription"></textarea><br/>
            <button id="btnSend">save</button>
        </div>
        <div style="height:40px;"></div>
        <div>🐞 Debug</div>
        <div id="debug" style="font-family:'Cascadia Mono';font-size:10px;border:solid 2px #000; padding:20px;"></div>
        
    </div>
</div>
<div style="display:flex;background-color:navy;color:white;padding:10px;">
    <div style="flex:1;"></div><div>📋 Version 1.0 📅 July 2020</div>
</div>
<Component id="_IDB" src="IDB.html"></Component>
<script>


var self = this;
var IDB = _IDB.exports;


const AssetSpec = {
    name : "asset",
    releases : [{
        version : 4,
        schema : {
            files : {
                blob : {},
                _meta : {
                    index : []
                }
            },
            files_config : {
                name : {unique:true},
                fileid : {},
                date : {},
                type : {},
                comments : {},
                _meta : {
                    index : ["name","date"]
                }
            },
            files_meta : {
                name : {unique:true},
                fileid : {},
                date : {},
                comments : {},
                _meta : {
                    index : ["name","date"]
                }
            }
        }
    }]
};

if(this.fail) {
    main.el.style.display = "none";
    message.$.elementSetPacketAsync(`Hello World!`);
}

btnResQVGA.el.addEventListener("click",()=>{
    screenWidth.el.value = "320";
    screenHeight.el.value = "240";
});
btnResVGA.el.addEventListener("click",()=>{
    screenWidth.el.value = "640";
    screenHeight.el.value = "480";
});
btnResSVGA.el.addEventListener("click",()=>{
    screenWidth.el.value = "800";
    screenHeight.el.value = "600";
});
btnResXGA.el.addEventListener("click",()=>{
    screenWidth.el.value = "1024";
    screenHeight.el.value = "768";
});
btnResFWVGA.el.addEventListener("click",()=>{
    screenWidth.el.value = "854";
    screenHeight.el.value = "480";
});
btnResHD720.el.addEventListener("click",()=>{
    screenWidth.el.value = "1280";
    screenHeight.el.value = "720";
});
btnResHD1080.el.addEventListener("click",()=>{
    screenWidth.el.value = "1920";
    screenHeight.el.value = "1080";
});
btnResTwitter1.el.addEventListener("click",()=>{
    screenWidth.el.value = "440";
    screenHeight.el.value = "220";
});
btnResFacebook1.el.addEventListener("click",()=>{
    screenWidth.el.value = "500";
    screenHeight.el.value = "282";
});
btnResFacebook2.el.addEventListener("click",()=>{
    screenWidth.el.value = "480";
    screenHeight.el.value = "120";
});


listPanel.el.style.height = (window.innerHeight-90) + "px";
mainPanel.el.style.height = (window.innerHeight-130) + "px";




this.app = {
    id : self.genId("APP"),
    events : Class.create("WithEvents"),
    channel : new BroadcastChannel('recorder'),
    externalSources : {},
    panel : {
        input : {
            visible : true
        },
        layer : {
            gridChange : null,
            posChange : null,
            sizeChange : null
        },
        output : {
            visible : true
        },
        upload : {
            visible : false
        }
    },
    stream : null,
    tracks : [],
    recordType : "none",
    recordState : "stopped",
    video : {
        mode : "none",
        output : {
            init : false
        }
    },
    audio : {
        mode : "none",
        output : "default"
    },
    hasAudioTracks : function () { for(var x = 0; x < this.tracks.length;x++) if(this.tracks[x].type == "audio") return true; return false; },
    hasVideoTracks : function () { for(var x = 0; x < this.tracks.length;x++) if(this.tracks[x].type == "video") return true; return false; }
};

self.app.channel.onmessage = async function (ev) { 
    if(ev.data.type == "ping") {
        if(ev.data.id in self.app.externalSources) {
            self.app.externalSources[ev.data.id].date = new Date();
        } else {
            var obj = {
                id : ev.data.id,
                buffer : [],
                date : new Date(),
                update : false
            };
            
            console.log("connected",ev.data.id);
            // register as a possible input
            var schema = await selRecorderTab.$.elementPushPacketAsync(`
                <Component id="holder">
                    <option value="${ev.data.id}">${ev.data.id}</option>
                </Component>
            `);
            obj.schema = schema;
            self.app.externalSources[ev.data.id] = obj;
        }
    } else if(ev.data.type == "stream") {
        var listening = false;
        for(var x = 0; x < self.app.tracks.length;x++) {
            var track = self.app.tracks[x];
            if( track.data.tab == ev.data.id ) {
                //console.log(track,ev.data.id);
                listening = true;
            }
        }
        if(listening) {
            //console.log("RECEIVED");
            //console.log(ev.data.data);
            self.app.externalSources[ ev.data.id ].buffer.push( ev.data.data );
        }
    } else {
        console.log(ev.data);
    }
}

setInterval(()=>{
    self.app.channel.postMessage({
        type : "ping",
        id : self.app.id
    });
    var date = new Date();
    var sel = [];
    for(var id in self.app.externalSources) {
        if( date - self.app.externalSources[id].date > 5000) {
            console.log("disconnect",id);
            self.app.externalSources[id].schema.$.holder.elementsClear();
            sel.push(id);
        }
    }
    for(var x = 0; x < sel.length;x++) {
        delete self.app.externalSources[sel[x]];
    }
},1000);


self.app.audio.layers = [];

var default_style = {
    changed : true,
    fontFamily: 'Arial',
    fontSize: 20,
    fontStyle: 'italic',
    fontWeight: 'bold',
    fill: ['#ffffff', '#00ff99'], // gradient
    stroke: '#4a1850',
    strokeThickness: 3,
    dropShadow: true,
    dropShadowColor: '#000000',
    dropShadowBlur: 2,
    dropShadowAngle: Math.PI / 6,
    dropShadowDistance: 2,
    wordWrap: true
};

var default_video_layers = [{ 
    name : "ms", track : -1, lastTrack : -1, grid : [1,1], pos : [0,0], size : [1,1], style : Object.assign({},default_style)
},{ 
    name : "pip", track : -1, lastTrack : -1, grid : [2,2], pos : [1,1], size : [1,1], style : Object.assign({},default_style)
},{
    name : "21_left", track :-1, lastTrack : -1,grid:[2,1],pos:[0,0],size:[1,1], style : Object.assign({},default_style)
},{
    name : "21_right", track :-1, lastTrack : -1,grid:[2,1],pos:[1,0],size:[1,1], style : Object.assign({},default_style)
},{
    name : "12_top", track :-1, lastTrack : -1,grid:[1,2],pos:[0,0],size:[1,1], style : Object.assign({},default_style)
},{
    name : "12_bottom", track :-1, lastTrack : -1,grid:[1,2],pos:[0,1],size:[1,1], style : Object.assign({},default_style)
},{
    name : "bottom_subtitle", track :-1, lastTrack : -1,grid:[12,12],pos:[3,10],size:[6,2], style : Object.assign({},default_style)
},{
    name : "middle_subtitle", track :-1, lastTrack : -1,grid:[12,12],pos:[3,5],size:[6,2], style : Object.assign({},default_style)
},{
    name : "top_subtitle", track :-1, lastTrack : -1,grid:[12,12],pos:[3,0],size:[6,2], style : Object.assign({},default_style)
}];


async function saveLayers() {
    var used = [];
    var lastKey = "";
    const deep = (inObject,stack) => {
        if(!stack) stack = [""];
        let outObject, value, key
        if (typeof inObject !== "object" || inObject === null) {
            return inObject // Return the value if inObject is not an object
        }

        // Create an array or object to hold the values
        outObject = Array.isArray(inObject) ? [] : {}
        var find = false;
        for(var x = 0; x < used.length;x++) {
            if(used[x] == inObject) {
                find = true;
                break;
            }
        }
        if(!find) { // do not copy circular.
            used.push(inObject);
            for (key in inObject) {
                //console.log(key);
                value = inObject[key]
                // Recursively (deep) copy for nested objects, including arrays
                lastKey = key;
                stack.push(key);
                outObject[key] = deep(value,stack)
                stack.pop();
            }
        } else {
            //console.log(lastKey,stack);
        }
        return outObject
    }

    var s = await IDB.service(AssetSpec);
    var filename = "//user/layers";
    var file_layers = await s.files_config.find("name",filename);
    if(file_layers) {
        var bw = new BinaryWriter();
        var copy = deep(self.app.video.layers);
        for(var x = 0; x < copy.length;x++) {
            if("schema" in copy[x]) {
                delete copy[x].schema;
            }
            if("track" in copy[x]) {
                copy[x].track = -1;
            }
            if("lastTrack" in copy[x]) {
                copy[x].lastTrack = -1;
            }
            if("update" in copy[x]) {
                delete copy[x].update;
            }
            if("selected" in copy[x]) {
                delete copy[x].selected;
            }
            if("init" in copy[x]) {
                delete copy[x].init;
            }
            if("msSprite" in copy[x]) {
                delete copy[x].msSprite;
            }
            if("changed" in copy[x].style) {
                delete copy[x].style.changed;
            }
        }
        console.log(copy);
        var file = JSON.stringify(copy);
        var file_ab = Binary.str2utf8ab(file);
        bw.u32(file_ab.byteLength);
        bw.add(file_ab);
        await s.files.update(file_layers.fileid,bw.toBlob());
    }
}

btnLayerChannelSaveAll.el.addEventListener("click",()=>{
    saveLayers();
});

async function loadLayers() {
    var s = await IDB.service(AssetSpec);
    var filename = "//user/layers";
    var file_layers = await s.files_config.find("name",filename);
    if(!file_layers) {
        // create
        var bw = new BinaryWriter();
        var file = JSON.stringify(default_video_layers);
        var file_ab = Binary.str2utf8ab(file);
        bw.u32(file_ab.byteLength);
        bw.add(file_ab);
        //console.log(await bw.toBlob().arrayBuffer());
        var file_layer_id = await s.files.add(bw.toBlob());
        //console.log(file_layer_id)
        var meta = {
            name: filename,
            fileid : file_layer_id, 
            type : "json",
            date : (new Date()).toISOString(), 
            comments : ""
        };
        //console.log(meta);
        var meta_id = await s.files_config.add(meta);
        return default_video_layers;
    } else {
        //console.log(file_layers.fileid);
        var blob = await s.files.find(file_layers.fileid);
        //console.log( blob );
        var br = new BinaryReader(blob,await blob.arrayBuffer());
        var size = br.u32();
        var nblob = br.toBlob(size);
        //console.log(nblob);
        var str_json = Binary.utf8ab2str( await nblob.arrayBuffer(), size );
        var layers = JSON.parse(str_json);
        return layers;
    }
}
self.app.video.layers = await loadLayers();
for(var x = 0; x < self.app.video.layers.length;x++) {
    self.app.video.layers[x].init = false;
}

self.app.video.layerSelected = null;
async function add_layer(layer) {
    if(!layer.init) {
        layer.init = true;
        layer.selected = false;
        var schema = await layerChannelList.$.elementPushPacketAsync(`
            <Component id="control">
                <div id="layer">${layer.name}</div>
            </Component>
        `);
        layer.schema = schema;

        schema.el.layer.addEventListener("mouseover",()=>{
            if(!layer.selected && self.app.video.layerSelected!=layer) {
                schema.el.layer.style.backgroundColor = "navy";
                schema.el.layer.style.color = "white";
            }
        });
        schema.el.layer.addEventListener("mouseleave",()=>{
            if(!layer.selected) {
                schema.el.layer.style.backgroundColor = "";
                schema.el.layer.style.color = "";
            }
        });
        schema.el.layer.addEventListener("click",()=>{
            var same = false;

            if(self.app.video.layerSelected == layer) {
                same = true;
            }
            if(self.app.video.layerSelected) {
                self.app.video.layerSelected.schema.$.layer.emit("deselect",[self.app.video.layerSelected]);
            }
            if(!layer.selected) {

                if(self.app.panel.layer.styleClick) {
                    dialogFont.el.removeEventListener("click",self.app.panel.layer.styleClick);
                }
                self.app.panel.layer.styleClick = async ()=>{

                    function getOS() {
                        var userAgent = window.navigator.userAgent,
                            platform = window.navigator.platform,
                            macosPlatforms = ['Macintosh', 'MacIntel', 'MacPPC', 'Mac68K'],
                            windowsPlatforms = ['Win32', 'Win64', 'Windows', 'WinCE'],
                            iosPlatforms = ['iPhone', 'iPad', 'iPod'],
                            os = null;

                        if (macosPlatforms.indexOf(platform) !== -1) {
                            os = 'Mac OS';
                        } else if (iosPlatforms.indexOf(platform) !== -1) {
                            os = 'iOS';
                        } else if (windowsPlatforms.indexOf(platform) !== -1) {
                            os = 'Windows';
                        } else if (/Android/.test(userAgent)) {
                            os = 'Android';
                        } else if (!os && /Linux/.test(platform)) {
                            os = 'Linux';
                        }

                        return os;
                    }

                    var font_select_visible = false;
                    fontModal.exports.body.$.elementsClear();

                    var fonts = [
                        "Arial",
                        "Arial Black",
                        "Calibri",
                        "Cambria",
                        "Candara",
                        "Comic Sans MS",
                        "Consolas",
                        "Courier",
                        "Courier New",
                        "Fixedsys",
                        "Helvetica",
                        "Impact",
                        "Modern",
                        "sans-serif",
                        "Script",
                        "Segoe Print",
                        "Segoe Script",
                        "Small Fonts",
                        "System",
                        "Terminal",
                        "Times New Roman",
                        "Verdana"
                    ];
                    var OS = getOS();
                    if(OS=="Linux") {
                        fonts = [
                            "aakar",
                            "Droid Sans Fallback",
                            "Dyuthi",
                            "Keraleeyam",
                            "Liberation Serif",
                            "Lohit Telugu",
                            "Manjari Thin",
                            "Navilu",
                            "Nimbus Roman",
                            "Purisa",
                            "Sawasdee",
                            "Suruma",
                            "Ubuntu",
                            "Ubuntu Condensed",
                            "Uroob",
                            "URW Gothic",
                            "Z003"
                        ];
                    }
                    var sel = 0; // Arial
                    for(var x = 0; x < fonts.length;x++) {
                        if(fonts[x] == layer.style.fontFamily) {
                            sel = x;
                            break;
                        }
                    }
                    var size = 40;
                    var bold = false;
                    var italic = false;

                    if(layer.style.fontStyle == 'italic') {
                        italic = true;
                    }
                    if(layer.style.fontWeight == 'bold') {
                        bold = true;
                    }
                    

                    var sb = [];
                    for(var x = 0; x < fonts.length;x++) {
                        sb.push(`
                            <div id="font${x}" style="cursor:pointer;padding-left:10px;"><span style="font-family:${fonts[x]};font-size:12px;">${fonts[x]}</span></div>
                        `)
                    }

                    var schema = await fontModal.exports.body.$.elementSetPacketAsync(`
                        <div style="font-size:16px;font-weight:bold;padding:6px;padding-left:10px;margin-bottom:40px;background-color:#333;color:white;">Select Text Font:</div>
                        <div style="padding-left:20px;padding-right:20px;">
                            <table width="100%" height="160">
                                <tr height="50">
                                    <td valign="top">
                                        <div style="display:flex;">
                                            <div style="flex:1;"></div>
                                            <div style="position:relative;max-height:20px;width:154px;max-width:154px;">
                                                <div style="position:absolute;left:0px;top:0px;max-height:100px;width:150px;overflow-y:auto;padding:2px;background-color:white;border:solid 1px #000;">
                                                    ${sb.join("")}
                                                </div>
                                            </div>
                                            <div>
                                            <button id="btnItalic">italics</button>
                                            <button id="btnBold">bold</button>
                                            size:<select id="szFont" value="${size}">
                                                <option value="8">8</option>
                                                <option value="9">9</option>
                                                <option value="10">10</option>
                                                <option value="11">11</option>
                                                <option value="12">12</option>
                                                <option value="13">13</option>
                                                <option value="14">14</option>
                                                <option value="16">16</option>
                                                <option value="18">18</option>
                                                <option value="20" selected>20</option>
                                                <option value="24">24</option>
                                                <option value="36">36</option>
                                                <option value="48">48</option>
                                                <option value="60">60</option>
                                                <option value="72">72</option>
                                                <option value="84">84</option>
                                                <option value="96">96</option>
                                            </select>
                                            </div>
                                            <div style="flex:1;"></div>
                                        </div>
                                    </td>
                                </tr>
                                <tr height="50">
                                    <td valign="top" align="center" style="padding:20px;max-height:50px;overflow:hidden;border:solid 1px #000;"><span id="sample">The quick brown fox jumps over the lazy dog</span></td>
                                </tr>
                                <tr height="50">
                                    <td valign="bottom">
                                        <div style="display:flex;">
                                            <div style="flex:1;"></div>
                                            <div style="flex:1;text-align:center;cursor:pointer;">❎ Cancel</div>
                                            <div style="flex:1;text-align:center;cursor:pointer;">✅ Ok</div>
                                            <div style="flex:1;"></div>
                                        </div>
                                    </td>
                                </tr>
                            </table>
                        </div>
                    `);

                    function setSample() {
                        schema.el.sample.style.fontFamily = fonts[sel];
                        schema.el.sample.style.fontSize = parseInt(schema.el.szFont.value) + "px";
                        schema.el.sample.style.fontStyle = italic ? 'italic' : 'normal';
                        schema.el.sample.style.fontWeight = bold ? 'bold' : 'normal';

                        layer.style.changed = true;
                        layer.style.fontFamily = fonts[sel];
                        layer.style.fontSize = parseInt(schema.el.szFont.value) + "px";
                        layer.style.fontStyle = italic ? 'italic' : 'normal';
                        layer.style.fontWeight = bold ? 'bold' : 'normal';

                    }
                    setSample();
                    schema.el.szFont.addEventListener("change",()=>{
                        setSample();
                    });
                    schema.el.btnItalic.addEventListener("click",()=>{
                        if(italic) {
                            italic = false;
                        } else {
                            italic = true;
                        }
                        setSample();
                    });
                    schema.el.btnBold.addEventListener("click",()=>{
                        if(bold) {
                            bold = false;
                        } else {
                            bold = true;
                        }
                        setSample();
                    });

                    function setFontFamily(index) {
                        schema.el["font"+index].addEventListener("mouseover",()=>{
                            schema.el["font"+index].style.backgroundColor = "black";
                            schema.el["font"+index].style.color = "white";
                        });
                        schema.el["font"+index].addEventListener("mouseleave",()=>{
                            schema.el["font"+index].style.backgroundColor = "";
                            schema.el["font"+index].style.color = "";
                        });
                        schema.el["font"+index].addEventListener("click",()=>{
                            if(font_select_visible) {
                                // select font
                                if(index!=sel) {
                                    layer.style.changed = true;
                                    layer.style.fontFamily = fonts[index];
                                    sel = parseInt(index);
                                }
                                setSample();
                                // hide list
                                for(var x = 0; x < fonts.length;x++) {
                                    if(sel!=x) {
                                        schema.el["font"+x].style.display = "none";
                                    } else {
                                        schema.el["font"+x].style.display = "";
                                    }
                                }
                                font_select_visible = false;
                            } else {
                                // show list
                                for(var x = 0; x < fonts.length;x++) {
                                    schema.el["font"+x].style.display = "";
                                }
                                font_select_visible = true;
                            }
                        });
                    }
                    for(var x = 0; x < fonts.length;x++) {
                        if(x!=sel) {
                            schema.el["font"+x].style.display = "none";
                        }
                        setFontFamily(x);
                    }
                    //displayFontDialog();
                    fontModal.exports.show();
                }
                dialogFont.el.addEventListener("click",self.app.panel.layer.styleClick);

                // begin bind grid,pos,size

                txtLayerChannelGrid.el.value = JSON.stringify(layer.grid);
                txtLayerChannelPos.el.value = JSON.stringify(layer.pos);
                txtLayerChannelSize.el.value = JSON.stringify(layer.size);
                
                if(self.app.panel.layer.gridChange) {
                    txtLayerChannelGrid.el.removeEventListener("keyup",self.app.panel.layer.gridChange);
                }
                self.app.panel.layer.gridChange = ()=> { 
                    layer.grid = JSON.parse(txtLayerChannelGrid.el.value); 
                    layer.update = true;
                    //saveLayers();
                }
                txtLayerChannelGrid.el.addEventListener("keyup",self.app.panel.layer.gridChange);
                if(self.app.panel.layer.posChange) {
                    txtLayerChannelPos.el.removeEventListener("keyup",self.app.panel.layer.posChange);
                }
                self.app.panel.layer.posChange = ()=> { 
                    layer.pos = JSON.parse(txtLayerChannelPos.el.value);
                    layer.update = true;
                    //saveLayers();
                }
                txtLayerChannelPos.el.addEventListener("keyup",self.app.panel.layer.posChange);
                if(self.app.panel.layer.sizeChange) {
                    txtLayerChannelSize.el.removeEventListener("keyup",self.app.panel.layer.sizeChange);
                }
                self.app.panel.layer.sizeChange = ()=> { 
                    layer.size = JSON.parse(txtLayerChannelSize.el.value); 
                    layer.update = true;
                    //saveLayers();
                }
                txtLayerChannelSize.el.addEventListener("keyup",self.app.panel.layer.sizeChange);
                
                // end bind

                self.app.video.layerSelected = layer;
                schema.el.layer.style.backgroundColor = "red";
                schema.el.layer.style.color = "white";
                layer.selected = true;

            } else {
                
                self.app.video.layerSelected = null;
                schema.el.layer.style.backgroundColor = "navy";
                schema.el.layer.style.color = "white";
                layer.selected = false;
            }
        });
        schema.$.layer.on("dispose",()=>{
            schema.$.control.elementsClear();
        });
        schema.$.layer.on("deselect",(layer)=>{
            layer.selected = false;
            schema.el.layer.style.backgroundColor = "";
            schema.el.layer.style.color = "";
        });
        
    }
}
async function refresh_layerchannels() {
    for(var x = 0; x < self.app.video.layers.length;x++) {
        await add_layer(self.app.video.layers[x]);
    }
}
refresh_layerchannels();

btnAddLayerChannel.el.addEventListener("click",()=>{
    var n = self.app.video.layers.length;
    console.log("add");
    var grid = [n+1,n+1];
    try { grid = JSON.parse(txtLayerChannelGrid.el.value); } catch(e) { }
    var pos = [n,n];
    try { pos = JSON.parse(txtLayerChannelPos.el.value); } catch(e) { }
    var size = [1,1];
    try { size = JSON.parse(txtLayerChannelSize.el.value); } catch(e) { }
    var config = {
        name:txtLayerChannelName.el.value,
        track : -1, lastTrack : -1, grid : grid, pos : pos, size : size, style : Object.assign({},default_style)
    };
    txtLayerChannelName.el.value = "";
    self.app.video.layers.push(config);
    console.log(config);
    saveLayers();

    refresh_layerchannels();
});

btnRemoveLayerChannel.el.addEventListener("click",()=>{
    console.log("selected",self.app.video.layerSelected)
    if(self.app.video.layerSelected && self.app.video.layers.length > 1 && self.app.video.layerSelected != self.app.video.layers[0]) {
        for(var x = 0; x < self.app.video.layers.length;x++) {
            if(self.app.video.layerSelected == self.app.video.layers[x]) {
                
                self.app.video.layers.splice(x,1); // remove from db
                break;
            }
        }
        self.app.video.layerSelected.schema.$.layer.emit("dispose");
        self.app.video.layerSelected = null;
        console.log("remove");
        saveLayers();
    }
})

btnFrontLayerChannel.el.addEventListener("click",async ()=>{
    if(self.app.video.layerSelected && self.app.video.layers.length > 0) {
        for(var x = 0; x < self.app.video.layers.length;x++) {
            if(self.app.video.layerSelected == self.app.video.layers[x]) {
                if(x + 1 < self.app.video.layers.length) { // can move to front
                    var tmp = self.app.video.layers[x];
                    self.app.video.layers[x] = self.app.video.layers[x+1];
                    self.app.video.layers[x+1] = tmp;

                    for(var y = x;y < self.app.video.layers.length;y++) {
                        self.app.video.layers[y].update = true;
                    }
                    for(var y = 0; y < self.app.video.layers.length;y++) {
                        self.app.video.layers[y].init = false;
                    }

                    // reorder layers on view
                    layerChannelList.$.elementsClear();
                    await refresh_layerchannels();

                    self.app.video.layerSelected.schema.el.layer.style.backgroundColor = "red";
                    self.app.video.layerSelected.schema.el.layer.style.color = "white";
                    self.app.video.layerSelected.selected = true;

                    //saveLayers();

                    // force repaint?
                    break;
                }
            }
        }
    }
});
btnBackLayerChannel.el.addEventListener("click",async ()=>{
    if(self.app.video.layerSelected && self.app.video.layers.length > 0) {
        for(var x = 1; x < self.app.video.layers.length;x++) {
            if(self.app.video.layerSelected == self.app.video.layers[x]) {
                if(x >= 1) { // can move to back
                    var tmp = self.app.video.layers[x];
                    self.app.video.layers[x] = self.app.video.layers[x-1];
                    self.app.video.layers[x-1] = tmp;

                    for(var y = x-1;y < self.app.video.layers.length;y++) {
                        self.app.video.layers[y].update = true;
                    }
                    for(var y = 0; y < self.app.video.layers.length;y++) {
                        self.app.video.layers[y].init = false;
                    }
                    // reorder layers on view

                    layerChannelList.$.elementsClear();

                    //saveLayers();

                    await refresh_layerchannels();

                    self.app.video.layerSelected.schema.el.layer.style.backgroundColor = "red";
                    self.app.video.layerSelected.schema.el.layer.style.color = "white";
                    self.app.video.layerSelected.selected = true;
                    // force repaint?
                    break;
                }
            }
        }
    }
});


function displayFontDialog() {
    fontModal.exports.show();
}


lblUpload.el.addEventListener("click",()=>{
    if(!self.app.panel.upload.visible) {
        panelUpload.el.style.display = "";
        self.app.panel.upload.visible = true;
    } else {
        panelUpload.el.style.display = "none";
        self.app.panel.upload.visible = false;
    }

});

btnUpload.el.addEventListener("click",()=>{
    if(fileUpload.el.files.length<=0) return;
    var file = fileUpload.el.files[0];
    let reader = new FileReader();
    reader.onload = async function(e) {
        let blob = new Blob([new Uint8Array(e.target.result)], {type: file.type });

        var s = await IDB.service(AssetSpec);
        var id = txtUploadFilename.el.value;
        if(id.indexOf("//")==0) {
            alert("can't contain // at beginning of filename.")
            return;
        }
        var fileMeta = await s.files_meta.find("name",id);
        
        if(!fileMeta) {
            // get blob of file
            var file_id = await s.files.add(blob);
            var meta_id = await s.files_meta.add({
                name: id,
                fileid : file_id, 
                date : (new Date()).toISOString(), 
                comments : txtUploadDescription.el.value
            });
            txtUploadFilename.el.value = "";
            txtUploadDescription.el.value = "";
            fileUpload.el.value = "";

            panelUpload.el.style.display = "none";
            self.app.panel.upload.visible = false;

            console.log("UPLOAD");
            refresh_list();
        }
    };
    reader.readAsArrayBuffer(file);


    


});

async function refresh_list(update) {
    
    /*
    var data = null;
    if(update) {
        data = await new Promise((resolve,reject)=>{
            Import({url:"/list",method:"GET"})
            .done((data)=>{
                //alert(data);
                var json = JSON.parse(data);
                resolve(json);
                
            })
            .send();
        });
    } else {
        data = await self.refresh_list;
    }
    */
   /*
    if(data?.result) {
        schema.$.list.elementsClear();
        for(var x = 0; x < data.data.length;x++) {
            addAsset(data.data[x]);
        }
    }
    */
    schema.$.list.elementsClear();
    //console.log("refresh_list before instanciating indexeddb. no calls for async return after IDB.service, lost async (0)");
    var s = await IDB.service(AssetSpec);
    //console.log("refresh_list before filter, lost async (1)");
    var list = await s.files_meta.filter((key,val)=> true);
    //console.log("refresh_list before filter, lost async (2)");
    
    //console.log("refresh_list",list);
    for(var x = 0; x < list.length;x++) {
        addAsset2(list[x]);
    }
    
}
refresh_list();

btnClearStage.el.addEventListener("click",()=>{
    self.app.video.canvasFlag = false;
    self.app.video.output.init = false;
    camera_holder.$.elementsClear();
    tracksView.$.elementsClear();
    if(self.app.video.pixi) self.app.video.pixi.destroy();

    // stop video streams
    for(var x = 0; x < self.app.tracks.length;x++) {
        var track = self.app.tracks[x];
        if(track.type == "video" && ( track.data.type == "camera" || track.data.type == "clip" || track.data.type == "screen")) {
            track.data.stream.getTracks().forEach((track)=>{
                track.stop();
            })
        }
    }
    mic_holder.$.elementsClear();
    // stop audio streams
    for(var x = 0; x < self.app.audio.layers.length;x++) {
        var layer = self.app.audio.layers[x];
        layer.stream.getTracks().forEach((track)=>{
            track.stop();
        });
    }
    self.app.audio.layers.splice(0,self.app.audio.layers.length);

    self.app.tracks.splice(0,self.app.tracks.length);
    self.app.events.emit("updateTracks");
});

lblInputSettings.el.addEventListener("click",()=>{
    if(self.app.panel.input.visible) {
        panelInputSettings.el.style.display = "none";
        self.app.panel.input.visible = false;
    } else {
        panelInputSettings.el.style.display = "";
        self.app.panel.input.visible = true;

    }
})

lblOutputSettings.el.addEventListener("click",()=>{
    if(self.app.panel.output.visible) {
        panelOutputSettings.el.style.display = "none";
        self.app.panel.output.visible = false;
    } else {
        panelOutputSettings.el.style.display = "";
        self.app.panel.output.visible = true;

    }
})



// https://rawgit.com/Miguelao/demos/master/mediarecorder.html
//https://webrtc.github.io/samples/src/content/capture/canvas-record/
//https://webrtc.github.io/samples/src/content/capture/canvas-record/
function log(str) {
    debug.$.elementPushPacketAsync(`<div>${str}</div>`);
}
//canvas



// devices

var stream = null;
self.app.stream = null;


let audioStream0 = null;

try {
    try {
        var stream0 = await navigator.mediaDevices.getUserMedia({audio:true});
        stream0.getTracks().forEach(function(track) {
            track.stop();
        });
    } catch(e) {}

    try {
        var stream0 = await navigator.mediaDevices.getUserMedia({video:true});
        stream0.getTracks().forEach(function(track) {
            track.stop();
        });
    } catch(e) {}
    navigator.mediaDevices.enumerateDevices()
    .then(gotDevices)
    .catch((error)=>{
        log('Error: '+ error.message);   
    });
} catch(e) {
    console.log(e);
}




async function gotDevices(deviceInfos) {
    
    var firstAudioOutput = true;
    for (let i = 0; i !== deviceInfos.length; ++i) {
        const deviceInfo = deviceInfos[i];
        var mark = false;
        if (deviceInfo.kind === 'audioinput') {
            var schema = await mic_devices.$.elementPushPacketAsync(`
                <option id="opt">${ deviceInfo.label || 'mic' + (mic_devices.el.length+1) }</option>
            `);
            schema.el.opt.setAttribute("value",deviceInfo.deviceId);
            log(deviceInfo.kind + ": " + deviceInfo.label +
                " id = " + deviceInfo.deviceId);
            schema.el.opt.setAttribute("value",deviceInfo.deviceId);
            
        } else if (deviceInfo.kind === 'videoinput') {
            var schema = await video_devices.$.elementPushPacketAsync(`
                <option id="opt">${ deviceInfo.label || 'camera ' +
                (video_devices.el.length + 1) }</option>
            `)
            //alert(deviceInfo.deviceId);
            log(deviceInfo.kind + ": " + deviceInfo.label +
                " id = " + deviceInfo.deviceId);
            
                schema.el.opt.setAttribute("value",deviceInfo.deviceId);
        } else {
            mark = true;
        }

        if(deviceInfo.kind == "audiooutput") {
            var schema = await audio_output_devices.$.elementPushPacketAsync(`
                <option id="opt">${ deviceInfo.label || 'audioin ' +
                (audio_output_devices.el.length + 1) }</option>
            `)
            schema.el.opt.setAttribute("value",deviceInfo.deviceId);
            if(firstAudioOutput) {
                audio_output_devices.el.setAttribute("value",deviceInfo.deviceId);
                firstAudioOutput = false;
            }
            log(deviceInfo.kind + ": " + deviceInfo.label +
                " id = " + deviceInfo.deviceId);
        }
        if(mark) {
            log("OTHER:"+deviceInfo.kind + ": " + deviceInfo.label +
                " id = " + deviceInfo.deviceId);
        }
  }
}


var micNo = 0;
btnAddMic.el.addEventListener("click",async ()=>{

    const constraints = {
        audio : {
            deviceId : { exact : mic_devices.el.value }
        }
    };
    var schema = await mic_holder.$.elementPushPacketAsync(`
        <audio id="control"></audio>
    `);
    var audio_stream = null;
    try {
        audio_stream = schema.el.control.srcObject = await navigator.mediaDevices.getUserMedia(constraints);
    } catch(e) {
        audio_stream = schema.el.control.src = window.URL.createObjectURL(await navigator.mediaDevices.getUserMedia(constraints));
    }
    self.app.audio.layers.push({
        type : "audio",
        source : "mic",
        stream : audio_stream,
        el : schema.el.control
    });
    self.app.tracks.push({
        type : "audio",
        source : "mic",
        data : {
            name : "mic" + micNo
        },
        id : self.genId("TRACK0"),
        layer : self.app.audio.layers.length,
        events : []
    });
    micNo++;
    self.app.events.emit("updateTracks");
    // mic return
    //schema.el.control.play();
});

btnAddAudioFile.el.addEventListener("click",async ()=>{
    function addTrack(file) {
        var reader = new FileReader();
        reader.onload = async function(e) {
            var arrayBuffer = this.result;
            var type = file.type.indexOf("audio/") !=-1 ? "audio" : null;
            if(type == null) { console.log("not an audio file : " + file.name); return; }
            var audio = new AudioContext();
            var bufferSource = await audio.decodeAudioData(arrayBuffer);
            var track = {
                type : type,
                source : "file",
                id : self.genId("TRACK0"),
                data : {
                    mime : file.type,
                    name : file.name,
                    audio : audio,
                    buffer : bufferSource
                },
                events : []
            };
            fileAudio.el.value = "";
            self.app.tracks.push(track);
            //console.log(track);
            self.app.events.emit("updateTracks");
        }
        reader.readAsArrayBuffer(file);
    }
    for(var x = 0; x < fileAudio.el.files.length;x++) {
        addTrack(fileAudio.el.files[x]);
    }
});


btnAddImageVideoFile.el.addEventListener("click",async ()=>{
    function addTrack(file) {
        var reader = new FileReader();
        reader.onload = async function(e) {
            var arrayBuffer = this.result;
            var type = file.type.indexOf("image/") !=-1 ? "image" : null;
            if(type != null) { 
                var img = new Image();
                var blob =  new Blob([arrayBuffer]);
                img.src = window.URL.createObjectURL(blob);
                var track = {
                    type : "video",
                    id : self.genId("TRACK0"),
                    data : {
                        mime : file.type,
                        name : file.name,
                        type : "image",
                        blob,
                        el : img
                    },
                    events : []
                };
                fileImage.el.value = "";
                self.app.tracks.push(track);
                //console.log(track);
                self.app.events.emit("updateTracks");
            } else {
                type = file.type.indexOf("video/") != -1 ? "video" : null;
                if(type != null) {
                    var blob = new Blob([arrayBuffer]);
                    var video = document.createElement("video");
                    video.src = window.URL.createObjectURL(blob);
                    var stream = video.captureStream();
                    console.log("video file : " + file.name);
                    var track = {
                        type : "video",
                        id : self.genId("TRACK0"),
                        data : {
                            mime : file.type,
                            name : file.name,
                            type : "clip",
                            stream,
                            el : video
                        },
                        events : []
                    };
                    video.play();
                    self.app.tracks.push(track);
                    //console.log(track);
                    self.app.events.emit("updateTracks");
                } else {
                    var ext = "";
                    if(file.name.length >= 4) {
                        ext = file.name.substring(file.name.length-4);
                    }
                    if(ext == ".ncp") {
                        // may check for version and signature, to handle/bind private data of author.
                        throw new Error("not implemented external ncp files. contact an especialist.");
                    } else {
                        console.log("not an image/video file : " + file.name + " : " + file.type); return; 
                    }
                    
                }
            }
        }
        reader.readAsArrayBuffer(file);
    }
    for(var x = 0; x < fileImage.el.files.length;x++) {
        addTrack(fileImage.el.files[x]);
    }

});
var textNb = 0;
btnAddText.el.addEventListener("click",()=>{
    var track = {
        type : "video",
        id : self.genId("TRACK0"),
        data : {
            name : "text" + textNb,
            type : "text",
            value : ""
        },
        events : []
    }
    textNb++;
    self.app.tracks.push(track);
    self.app.events.emit("updateTracks");
});
var htmlNb = 0;
btnAddHtml.el.addEventListener("click",()=>{
    var track = {
        type : "video",
        id : self.genId("TRACK0"),
        data : {
            name : "html" + textNb,
            type : "html",
            value : ""
        },
        events : []
    }
    textNb++;
    self.app.tracks.push(track);
    self.app.events.emit("updateTracks");
});

cameraDevice = null;

var cameraNb = 0;
btnAddCamera.el.addEventListener("click",async ()=>{

    const constraints = {
        video: {
            deviceId: { exact : video_devices.el.value }
        }
    };
    var videoel = document.createElement("video");
    var stream = null;
    try {
        stream = videoel.srcObject = await navigator.mediaDevices.getUserMedia(constraints);
    } catch (error) {
        stream = videoel.src = window.URL.createObjectURL(await navigator.mediaDevices.getUserMedia(constraints));
    }
    document.body.appendChild(videoel);
    videoel.style.display = "none";
    videoel.play();
    var track = {
        type : "video",
        id : self.genId("TRACK0"),
        data : {
            name : "camera" + cameraNb,
            type : "camera",
            stream : stream,
            el : videoel
        },
        events : []
    };
    cameraNb++;
    self.app.tracks.push(track);
    //console.log(track);
    self.app.events.emit("updateTracks");
});

/*
btnSetScreen.el.addEventListener("click",async ()=>{
    
    
    

    if(cameraDevice) {
        cameraDevice.pause();
        stream.getTracks().forEach(function(track) {
          track.stop();
        });
        cameraDevice.style.display = "none";
        camera_holder.$.elementsClear();
    }

    if(self.app.video.mode == "play") {
        recordHolder.el.style.display = "";
        playscreen.el.style.display = "none";
    }
    self.app.video.mode = "desktop";

    stream.getTracks().forEach((track)=>{
        track.onended = function(event) {
            log("end of screen capture");
            
            stopRecording();
        }
    });

    schema.el.control.play();
    cameraDevice = schema.el.control;
});
*/
var screenNb = 0;
btnAddScreen.el.addEventListener("click",async ()=>{
    const constraints = { video : true };
    var videoel = document.createElement("video");
    var stream = null;
    if (navigator.getDisplayMedia) {
        stream = videoel.srcObject = await navigator.getDisplayMedia(constraints);
    } else if (navigator.mediaDevices.getDisplayMedia) {
        stream = videoel.srcObject = await navigator.mediaDevices.getDisplayMedia(constraints);
    } else {
        stream = videoel.srcObject = await navigator.mediaDevices.getUserMedia({video: {mediaSource: 'screen'}});
    }
    videoel.play();

    var track = {
        type : "video",
        id : self.genId("TRACK0"),
        data : {
            name : "screen"+screenNb,
            type : "screen",
            stream : stream,
            el : videoel
        },
        events : []
    };
    screenNb++;
    self.app.tracks.push(track);
    //console.log(track);
    self.app.events.emit("updateTracks");

});

btnSetVideoNone.el.addEventListener("click",()=>{

    

    if(cameraDevice) {
        cameraDevice.pause();
        stream.getTracks().forEach(function(track) {
          track.stop();
        });
        cameraDevice.style.display = "none";
        camera_holder.$.elementsClear();
    }

    if(self.app.video.mode == "play") {
        recordHolder.el.style.display = "";
        playscreen.el.style.display = "none";
    }

    self.app.video.mode = "none";
    camera_holder.$.elementsClear();
    playscreen.el.style.display = "none";  
    
});
btnSetAudioNone.el.addEventListener("click",()=>{
    
    

    for(var x = 0; x < self.app.audio.layers.length;x++) {
        var layer  = self.app.audio.layers[x];
        layer.stream.getTracks().forEach((track)=>{
            track.stop();
        });
    }
    self.app.audio.layers.splice(0,self.app.audio.layers.length);
    /*
    if(audioStream0) audioStream0.getTracks().forEach((track)=>{
        track.stop();
    })
    */
});
var tabNb = 0;
btnAddRecorderTab.el.addEventListener("click",()=>{
    var track = {
        type : "video",
        id : self.genId("TRACK0"),
        data : {
            name : "recordertab"+tabNb,
            type : "recordertab",
            tab : selRecorderTab.el.value
        },
        events : []
    };
    tabNb++;
    self.app.tracks.push(track);
    //console.log(track);
    self.app.events.emit("updateTracks");

});

let mediaRecorder;
let recordedBlobs = [];
let sourceBuffer;

const mediaSource = new MediaSource();
mediaSource.addEventListener('sourceopen', function handleSourceOpen(event) {
    log('MediaSource opened');
    sourceBuffer = mediaSource.addSourceBuffer('video/webm; codecs="vp8"');
    log('Source buffer: ', sourceBuffer);
}, false);

log('Started stream capture from canvas element: '+ stream);




function toggleRecording() {
    if (btnRecord.el.textContent === 'start recording') {
        startRecording();
    } else {
        stopRecording();
        btnRecord.el.textContent = 'start recording';
        btnPlay.el.disabled = false;
        btnDownloadMovie.el.disabled = false;
    }
}

function handleDataAvailable(event) {
    
    if (event.data && event.data.size > 0) {
        //console.log("DATA",event.data);
        recordedBlobs.push(event.data);
    } else {
        //console.log( mediaRecorder.requestData() );
        //console.log(event);
    }
}

async function handlePause(event) {
    log('Recorder paused: ', event);
}
async function handleStop(event) {
    log('Recorder stopped: ', event);
    await self.app.audio.ctx.close();

    for(var x = 0; x < self.app.audio.recordTracks.length;x++) {
        console.log("removing tracks");
        stream.removeTrack(self.app.audio.recordTracks[x]);
    }

    var duration = Date.now() - self.app.start;
    // convert recorded blobs and save with duration.
    var buggyBlob = new Blob(recordedBlobs, { type: 'video/webm' });

    ysFixWebmDuration(buggyBlob, duration, async function(fixedBlob) {

        recordedBlobs = [fixedBlob];
        if(self.app.video.mode == "none") {
            const superBuffer = new Blob(recordedBlobs, {type: 'audio/webm'});
            var url = (window.URL || window.webkitURL).createObjectURL(superBuffer);
            var schema = await playaudio.$.elementSetPacketAsync(`
                <audio id="audio" controls>
                    <source src="`+url+`" type="audio/webm">
                    Your browser does not support the audio tag.
                </audio>
            `);
            self.app.audio.control = schema.el.audio;
            
            delete self.app.events.hitTrack;
        } else {
            const superBuffer = new Blob(recordedBlobs, {type: 'video/webm'});
            playscreen.el.src = window.URL.createObjectURL(superBuffer);
            
        }
        
        self.app.recordState = "stopped";

    });

    
}




// The nested try blocks will be simplified when Chrome 47 moves to Stable
async function startRecording() { // take 'stream' to MediaRecorder, to setup stream go to 'updateTracks'
    if(!self.app.hasVideoTracks() && !self.app.hasAudioTracks()) {
        throw new Error("(you must select some input device)");
        return;
    }

    self.app.start = Date.now();

    recordHolder.el.style.display = "";
    recordedBlobs = [];
    if(self.app.events.hitTrack)
        self.app.events.off("hitTrack",self.app.events.hitTrack);

    var audioCtx = new AudioContext();
    self.app.audio.ctx = audioCtx;
    self.app.audio.recordTracks = [];

    var audioMixer = audioCtx.createMediaStreamDestination();

    for(var x = 0; x < self.app.audio.layers.length;x++) {
        var layer = self.app.audio.layers[x];
        layer.device = {};
        layer.device.source = audioCtx.createMediaStreamSource(layer.stream);
        layer.device.gain = audioCtx.createGain();
        layer.device.source.connect(layer.device.gain);
        layer.device.gain.gain.value = 0.5;
        layer.device.gain.connect(audioMixer);
    }

    if(self.app.hasAudioTracks()) {
        self.app.events.hitTrack = (n)=>{
            if(n < self.app.tracks.length && self.app.tracks[n].type == "audio") {
                var playback = audioCtx.createBufferSource();
                var playbackGain = audioCtx.createGain();
                playback.buffer = self.app.tracks[n].data.buffer;
                playback.connect(playbackGain);
                playbackGain.gain.value = 0.5;
                playbackGain.connect(audioMixer);
                //playback.connect(audioCtx.destination);
                playback.start();
            }
            console.log("hit",self.app.tracks[n]);
        };
        self.app.events.on("hitTrack",self.app.events.hitTrack);

        // null signal to record empty audio space if mic is not activated
        var myArrayBuffer = audioCtx.createBuffer(2, audioCtx.sampleRate, audioCtx.sampleRate);
        for (var channel = 0; channel < myArrayBuffer.numberOfChannels; channel++) {
            var nowBuffering = myArrayBuffer.getChannelData(channel);
            for (var i = 0; i < myArrayBuffer.length; i++) {
                nowBuffering[i] = 0;
            }
        }
        var source = audioCtx.createBufferSource();
        source.buffer = myArrayBuffer;
        source.connect(audioMixer);
        source.loop = true;
        source.start();

    }

    // mixing audio and video
    if( ( self.app.hasAudioTracks() ) && self.app.hasVideoTracks() ) {
        console.log("MIXED IN AUDIO AND VIDEO");
        audioMixer.stream
            .getAudioTracks()
            .forEach((audioTrack) => {
                self.app.audio.recordTracks.push(audioTrack);
                console.log(audioTrack);
                stream.addTrack(audioTrack);
            });
        
    }

    if( self.app.hasVideoTracks() ) {
        self.app.recordType = "video";
    } else {
        self.app.recordType = "audio";
    }

    var options = {};
    if(self.app.recordType == "video") {

        console.log("VIDEO RECORD TYPE");
        options.mimeType =  'video/webm';
        try {
            mediaRecorder = new MediaRecorder(stream, options);
        } catch (e0) {
            try {
                options.mimeType = 'video/webm,codecs=vp9';
                mediaRecorder = new MediaRecorder(stream, options);
            } catch (e1) {
                try {
                    options = 'video/vp8'; // Chrome 47
                    mediaRecorder = new MediaRecorder(stream, options);
                } catch (e2) {
                    log(`MediaRecorder is not supported by this browser.`);
                    log('Exception while creating MediaRecorder:'+ e2);
                    return;
                }
            }
        }
    } else {

        //stream = new MediaStream(stream.getAudioTracks());
        stream = audioMixer.stream;
        try {
            options.mimeType =  'audio/webm';
            mediaRecorder = new MediaRecorder(stream, options);
            
        } catch(e) {
            try {
                options.mimeType = 'audio/webm;codecs=opus';
                mediaRecorder = new MediaRecorder(stream, options);
                
            } catch(e1) {
                log(`Media Recorder is not supported by this browser.`);
                log('Exception while creating MediaRecorder:'+ e1);
                return;
            }
        }
    }

    log('Created MediaRecorder', mediaRecorder, 'with options', options);
    btnRecord.el.textContent = 'stop recording';
    btnPlay.el.disabled = true;
    btnDownloadMovie.el.disabled = true;
    mediaRecorder.onstop = handleStop;
    mediaRecorder.onpause = handlePause;
    mediaRecorder.ondataavailable = handleDataAvailable;
    mediaRecorder.onerror = function(error) {
        console.log(error.name);
        console.log(error);
    }
    self.app.recordState = "recording";
    mediaRecorder.start(1000/30);
    try {

    } catch(e) {
        log("error on media recorder start");
        log(e.message);
    }

    log('MediaRecorder started' + mediaRecorder);
}

function stopRecording() {
    if(mediaRecorder.state != "inactive") { 
        mediaRecorder.stop();    
    } else { // user stopped sharing screen.
        self.app.video.mode = "none";
        
    }
    log('Recorded Blobs: '+ recordedBlobs.length);
    playscreen.el.controls = true;
}
async function download2() {
    var nblob = await makeNcpBlob(recordedBlobs);
    const url = window.URL.createObjectURL(nblob);
    const a = document.createElement('a');
    a.style.display = 'none';
    a.href = url;
    a.download = 'last_record.ncp';
    document.body.appendChild(a);
    a.click();
    setTimeout(() => {
        document.body.removeChild(a);
        window.URL.revokeObjectURL(url);
    }, 10000);
}


async function download() {
    if(false) {
        var nblob = await makeNcpBlob(recordedBlobs);
        const url = window.URL.createObjectURL(nblob);
        const a = document.createElement('a');
        a.style.display = 'none';
        a.href = url;
        a.download = 'last_record.ncp';
        document.body.appendChild(a);
        a.click();
        setTimeout(() => {
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }, 10000);
    } else {
        var blob,type;
        if(self.app.video.mode=="none") {
            blob = new Blob(recordedBlobs, {type: 'audio/webm'});
            type = "audio.webm";
        } else {
            blob = new Blob(recordedBlobs, {type: 'video/webm'});
            type = "video.webm";
        }

        

        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.style.display = 'none';
        a.href = url;
        a.download = 'last_record.webm';
        document.body.appendChild(a);
        a.click();
        setTimeout(() => {
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }, 10000);
    }
}
btnRecord.el.addEventListener("click",()=>{ toggleRecording(); });
btnPlay.el.addEventListener("click",()=>{ 

    playholder.el.style.display = "";
    recordHolder.el.style.display = "none";
    if(self.app.recordType == "audio") {
        playscreen.el.style.display = "none";
        self.app.audio.control.play();
        
    } else if(self.app.recordType == "video") {
        playscreen.el.style.display = "";
        playaudio.$.elementsClear();
        playscreen.el.style.width = "100%";
        playscreen.el.play();  
        self.app.video.mode = "play";
    }
});
btnDownloadMovie.el.addEventListener("click",()=>{ download(); });


async function makeNcpBlob(blobs) {
    var blob,type;
    if(self.app.video.mode=="none") {
        blob = new Blob(recordedBlobs, {type: 'audio/webm'});
        type = "audio.webm";
    } else {
        blob = new Blob(recordedBlobs, {type: 'video/webm'});
        type = "video.webm";
    }

    var config_str = JSON.stringify({
        version : [0,0,2],
        type : type,
        main : "webm"
    });
    var config_ab = Binary.str2utf8ab(config_str);
    var webm_ab = await blob.arrayBuffer()
    var ncp_blob = new Blob( 
        new BinaryWriter().u32(config_ab.byteLength).data.concat([config_ab]) 
            .concat(
                new BinaryWriter().u32(webm_ab.byteLength).data.concat([webm_ab])
            ),
        {mime:"application/ncp"}
    );
    return ncp_blob;
}
/*
<div style="padding:10px;border:solid 1px #000;">
            Filename:<br/><input id="txtSaveFileName" type="text"/><button id="btnSaveFilenameGenerate">generate</button><br/>
            Description:<br/><textarea id="txtSaveDescription"></textarea><br/>
            <button id="btnSend">save</button>
        </div>
*/
btnSaveFilenameGenerate.el.addEventListener("click",()=>{
    txtSaveFileName.el.value = self.genId("ASSET");
});
txtSaveFileName.el.value = self.genId("ASSET");
btnSend.el.addEventListener("click",async ()=>{
    //var nblob = await makeNcpBlob(recordedBlobs);
    var s = await IDB.service(AssetSpec);
    var id = txtSaveFileName.el.value;
    if(id.indexOf("//")==0) {
        alert("can't contain // at beginning of filename.")
        return;
    }
    var fileMeta = await s.files_meta.find("name",id);
    var blob,type;
    if(!fileMeta) {
        if(self.app.hasVideoTracks()) {
            blob = new Blob(recordedBlobs, {type: 'video/webm'});
            type = "video.webm";
        } else {
            blob = new Blob(recordedBlobs, {type: 'audio/webm'});
            type = "audio.webm";
        }
        var file_id = await s.files.add(blob);
        var meta_id = await s.files_meta.add({
            name:id,
            fileid : file_id, 
            date : (new Date()).toISOString(), 
            comments : txtSaveDescription.el.value
        });
        refresh_list();
    }

    /*
    Import({url:"/send",method:"POST",type:Import.Binary,data : nblob })
    .done((data)=>{
        console.log(data);
        var json = JSON.parse(data);
        if(!json.result) {
            alert("can't save this record, interrupted on server.");
            return;
        }
        refresh_list(true);
    })
    .send();
    */
});

var keyboard = {
    ctrl : false,
    shift : false,
}
window.addEventListener("keydoown",(e)=>{
    //console.log(e.keyCode);
    if(e.keyCode == 16) {
        keyboard.shift = true;
    }
    if(e.keyCode == 17) {
        keyboard.ctrl = true;
    }

});
window.addEventListener("keyup",(e)=>{
    //console.log(e.keyCode);
    if(e.keyCode == 37) {
    } else if(e.keyCode == 38) {
    } else if(e.keyCode == 39) {
    } else if(e.keyCode == 40) {
    }

    if(e.keyCode == 16) {
        keyboard.shift = false;
    }
    if(e.keyCode == 17) {
        keyboard.ctrl = false;
    }
});

btnNewDisplay.el.addEventListener("click",()=>{
    self.app.video.output.init = false;
    self.app.events.emit("updateTracks");
})
self.app.events.on("updateTracks",async ()=>{
    //console.log("update tracks");
    function setLayerChangeHandler(layer,x) {
        self.app.events.off("layer_"+layer.name+"_change",layer.change);
        var sellayer = self.app.video.layers[x];
        layer.change = async (context)=> {
            var pixi = context.pixi;
            var res = context.res;
            if((sellayer.update || sellayer.style.changed) && sellayer.track != -1) { // update on layer
                sellayer.update = false;
                //console.log(x,sellayer.track);
                var track = self.app.tracks[sellayer.track];
                //console.log("update layer " + layer.name + " changed ",sellayer.lastTrack,sellayer.track);
                if(track.type == "video") {
                    var resize = [res[0]/sellayer.grid[0], res[1]/sellayer.grid[1]];
                    if(track.data.type == "clip") {
                        if(!track.data.running) {
                            track.data.running = true;
                            console.log("clip");
                            track.data.el.currentTime= 0;
                            track.data.el.play();

                            var f = ()=>{
                                track.data.running = false;
                                sellayer.lastTrack = -1; // loop clip
                                track.data.el.removeEventListener("ended",self.app.video.clip.handler);
                            };
                            self.app.video.clip = {
                                handler : f
                            };
                            track.data.el.addEventListener("ended",f);
                        }
                    } else if(track.data.type == "recordertab") {
                        //self.app.externalSources
                        //track.data.tab // tab id

                        if( track.data.tab in self.app.externalSources) {
                            if( self.app.externalSources[track.data.tab].buffer.length > 0) {
                                var sel = self.app.externalSources[track.data.tab].buffer.length - 1;
                                if( track.data.lastExternalSource != sel ) {
                                    var img = new Image();
                                    var blob = self.app.externalSources[track.data.tab].buffer[ sel ];
                                    img.src = window.URL.createObjectURL(blob);
                                    track.data.el = img;
                                    track.data.texture = PIXI.Texture.from(track.data.el);
                                    track.data.lastExternalSource = sel;
                                    //var texture = track.data.texture ? track.data.texture : PIXI.Texture.from(track.data.el);
                                    //track.data.texture = texture;
                                }
                            }
                        }
                    } else if(track.data.type == "text") {
                        console.log("text");
                        var style = layer.style.changed? 
                            new PIXI.TextStyle(layer.style) : 
                            (
                                layer.pixi_style ? 
                                    layer.pixi_style : 
                                    new PIXI.TextStyle(layer.style) 
                            );
                        layer.style.changed = false;
                        layer.pixi_style = style;
                        if(sellayer.msSprite) {
                            pixi.stage.removeChild(sellayer.msSprite);
                            sellayer.msSprite.destroy();
                            sellayer.msSprite = null;
                        }
                        sellayer.msSprite = new PIXI.Text(track.data.value, style);
                        
                        sellayer.msSprite.x = sellayer.pos[0]*resize[0];
                        sellayer.msSprite.y = sellayer.pos[1]*resize[1];
                        sellayer.msSprite.width = resize[0]*sellayer.size[0];
                        sellayer.msSprite.height = resize[1]*sellayer.size[1];
                        pixi.stage.addChild(sellayer.msSprite);
                        track.data.oldValue = track.data.value;
                    } else if(track.data.type == "html") {
                        //console.log("html");
                        if(!track.data.cache) {
                            track.data.cache = {};
                        }
                        // make a cache of images
                        async function render_html_to_canvas(html, width, height, callback) {
                            var xml = await html_to_xml(html);
                            xml = xml.replace(/\#/g, '%23');
                            var data = "data:image/svg+xml;charset=utf-8,"+'<svg xmlns="http://www.w3.org/2000/svg" width="'+width+'" height="'+height+'">' +
                                '<foreignObject width="100%" height="100%">' +
                                xml+
                                '</foreignObject>' +
                                '</svg>';
                            var img = new Image();
                            img.onload = function () { callback(img); }
                            img.src = data;
                        }
                        async function html_to_xml(html) {
                            var doc = document.implementation.createHTMLDocument('');
                            doc.write(html);
                            
                            //https://ronvalstar.nl/render-html-to-an-image
                            function loadImageBase64(src) {
                                return new Promise((resolve,reject)=>{
                                    const canvas = document.createElement('canvas')
                                    const ctx = canvas.getContext('2d')
                                    const img = document.createElement('img');
                                    img.crossOrigin = "Anonymous";
                                    img.addEventListener('error', reject)
                                    img.addEventListener('load', ({target})=>{
                                        canvas.width = target.naturalWidth
                                        canvas.height = target.naturalHeight
                                        ctx.drawImage(target, 0, 0);
                                        resolve(canvas.toDataURL());
                                    });
                                    img.src = src
                                });
                            }
                            var stack = [doc.documentElement];
                            async function walk(stack) {
                                var item = stack.shift();
                                if(item.tagName == "IMG") {
                                    var rawimage = await loadImageBase64(item.getAttribute("src"));
                                    item.setAttribute("src",rawimage);
                                }
                                for(var x = 0; x < item.children.length;x++) {
                                    stack.push(item.children[x]);
                                }
                                if(stack.length>0) {
                                    await walk(stack);
                                }
                            }
                            await walk(stack);
                            doc.documentElement.setAttribute('xmlns', doc.documentElement.namespaceURI);
                            // doc.body -> pass to core
                            /*
                            event.emit("load core script");
                                self.Body = Class.create("UI.Body");
                                self.Body.nodeBuild(document.body, null);
                            */
                            var serial = (new XMLSerializer).serializeToString(doc.body);
                            return serial;
                        }
                        var img = null;
                        var size = [320,120];
                        await new Promise((resolve,reject)=>{
                            var str = track.data.value + "__" + size[0] + "__" + size[1];
                            if(str in track.data.cache) {
                                img = track.data.cache[str];
                                resolve();
                            } else {
                                render_html_to_canvas(track.data.value,size[0],size[1],(loaded_img)=>{
                                    img = loaded_img;
                                    track.data.cache[str] = loaded_img;
                                    resolve();
                                });
                            }
                        });
                        if(sellayer.msSprite) {
                            pixi.stage.removeChild(sellayer.msSprite);
                            sellayer.msSprite.destroy();
                            sellayer.msSprite = null;
                        }
                        var texture = PIXI.Texture.from(img);
                        sellayer.msSprite = new PIXI.Sprite(texture);
                        sellayer.msSprite.x = sellayer.pos[0]*resize[0];
                        sellayer.msSprite.y = sellayer.pos[1]*resize[1];
                        sellayer.msSprite.width = resize[0]*sellayer.size[0];
                        sellayer.msSprite.height = resize[1]*sellayer.size[1];
                        pixi.stage.addChild(sellayer.msSprite);
                    }
                    if(
                        (
                            track.data.type == "camera" || 
                            track.data.type == "screen" || 
                            track.data.type == "clip" || 
                            track.data.type == "image" || 
                            track.data.type == "recordertab"
                        ) &&
                        track.data.el 
                    ) {
                        //console.log("update video");
                        var texture = track.data.texture ? track.data.texture : PIXI.Texture.from(track.data.el);
                        track.data.texture = texture;
                        if(sellayer.msSprite) {
                            pixi.stage.removeChild(sellayer.msSprite);
                            sellayer.msSprite.destroy();
                            sellayer.msSprite = null;
                        }
                        console.log(sellayer.name);
                        sellayer.msSprite = new PIXI.Sprite(texture);
                        
                        sellayer.msSprite.x = sellayer.pos[0]*resize[0];
                        sellayer.msSprite.y = sellayer.pos[1]*resize[1];
                        sellayer.msSprite.width = resize[0]*sellayer.size[0];
                        sellayer.msSprite.height = resize[1]*sellayer.size[1];
                        pixi.stage.addChild(sellayer.msSprite);
                    }
                }
            } else if(sellayer.track == -1 && sellayer.lastTrack!=-1) {
                var track = self.app.tracks[sellayer.lastTrack];
                if(track.data.type == "clip") {
                    // check if is the only layer using that track
                    if(track.data.live.length==0) {
                        track.data.running = false;
                        track.data.el.pause();
                    }
                }
                if(sellayer.msSprite) {
                    pixi.stage.removeChild(sellayer.msSprite);
                    sellayer.msSprite.destroy();
                    sellayer.msSprite = null;
                }
            }
            sellayer.lastTrack = sellayer.track;
        };
        self.app.events.on("layer_"+layer.name+"_change",layer.change);
    }
    var layerButtons = [];
    for(var x = 0; x < self.app.video.layers.length;x++) {
        var layer = self.app.video.layers[x];
        layerButtons.push(`<div style="padding-left:5px;padding-right:5px;"><button id="btnLayer_${x}">${layer.name}</button></div>`);
        setLayerChangeHandler(layer,x);
    }
    layerButtons = layerButtons.join("");

    // layers may change
    async function addTrack(n,track) {
        if(!track.loaded) {
            
            if(!track) {
                throw new Error("no track; n=",n);
            }
            track.loaded = true;
            track.data.live = []; // mark which layers are transmiting the content.
            if(track.type == "audio") {
                if(track.source == "file") {
                    var schema = await tracksView.$.elementPushPacketAsync(`
                        <div style="display:flex;">
                            <div style="padding-left:5px;padding-right:5px;">🔊 ${(""+n).padStart(2,"0")}</div>
                            <div style="padding-left:5px;padding-right:5px;width:100px;overflow:hidden;white-space: nowrap;">${track.data.name}</div>
                            <div style="padding-left:5px;padding-right:5px;"><button id="btnHit">hit</button></div>
                        </div>
                    `);
                    schema.el.btnHit.addEventListener("click",()=>{
                        if (btnRecord.el.textContent === 'start recording') {
                            var playback = track.data.audio.createBufferSource();
                            var playbackGain = track.data.audio.createGain();
                            playback.buffer = self.app.tracks[n].data.buffer;
                            playback.connect(playbackGain);
                            playbackGain.gain.value = 0.5;
                            playback.connect(track.data.audio.destination);
                            playback.start();
                        }
                        self.app.events.emit("hitTrack",[n]);
                    });
                } else if(track.source == "mic") {
                    var schema = await tracksView.$.elementPushPacketAsync(`
                        <div style="display:flex;">
                            <div style="padding-left:5px;padding-right:5px;">🔊 ${(""+n).padStart(2,"0")}</div>
                            <div style="padding-left:5px;padding-right:5px;width:100px;overflow:hidden;white-space: nowrap;">${track.data.name}</div>
                        </div>
                    `);
                }
            } else if(track.type == "video") {
                if(track.data.type == "text") {
                    var schema = await tracksView.$.elementPushPacketAsync(`
                        <div style="display:flex;">
                            <div style="padding-left:5px;padding-right:5px;">🔊 ${(""+n).padStart(2,"0")}</div>
                            <div style="padding-left:5px;padding-right:5px;width:100px;overflow:hidden;white-space: nowrap;">${track.data.name}</div>
                            <div><input id="txtValue" type="text"/></div>
                            ${layerButtons}
                        </div>
                    `);
                    schema.el.txtValue.addEventListener("change",()=>{
                        track.data.value = schema.el.txtValue.value;
                    });
                    schema.el.txtValue.addEventListener("keyup",(e)=>{
                        if(e.keyCode == 13) {
                            schema.el.txtValue.value = "";
                        }
                        track.data.value = schema.el.txtValue.value;

                        for(var x = 0; x < track.data.live.length;x++) {
                            var item_layer = track.data.live[x];
                            for(var y = 0; y < self.app.video.layers.length;y++) {
                                if(self.app.video.layers[y].name == item_layer.name) {
                                    //console.log("UPDATE TEXT");
                                    self.app.video.layers[y].update = true;
                                }
                            }
                        }
                    });
                    function setHandler(schema,layer,x) {
                        schema.el["btnLayer_" + x].addEventListener("click",()=>{ // works like any pip layer
                            layer.update = true;
                            var found = false;
                            var sel_remove = [];
                            for(var y = 0; y < track.data.live.length;y++) {
                                if(track.data.live[y].name == layer.name) {
                                    found = true;
                                    layer.track = n;
                                    if(layer.track == n) { // on/off track
                                        console.log("off n:",n);
                                        layer.lastTrack = layer.track;
                                        layer.track = -1;
                                        sel_remove.push(y);
                                    } else {
                                        console.log("on");
                                        layer.lastTrack = layer.track;
                                        layer.track = n;
                                    }
                                    break;
                                }
                            }
                            for(var y = sel_remove.length-1;y>=0;y--) {
                                track.data.live.splice(sel_remove[y],1);
                            }
                            if(!found) {
                                console.log("on 1");
                                track.data.live.push({name : layer.name });
                                layer.lastTrack = layer.track;
                                layer.track = n;
                            }
                            if(self.app.recordState == "stopped") {
                                recordHolder.el.style.display = "";
                            }
                            self.app.events.emit("layer_"+layer.name+"_hit",[n]);
                        });
                    }
                    for(var x = 0; x < self.app.video.layers.length;x++) {
                        var layer = self.app.video.layers[x];
                        setHandler(schema,layer,x);
                    }

                } else if(track.data.type == "html") {
                    var schema = await tracksView.$.elementPushPacketAsync(`
                        <div style="display:flex;">
                            <div style="padding-left:5px;padding-right:5px;">🔊 ${(""+n).padStart(2,"0")}</div>
                            <div style="padding-left:5px;padding-right:5px;width:100px;overflow:hidden;white-space: nowrap;">${track.data.name}</div>
                            
                            ${layerButtons}
                            
                        </div>
                        <div style="display:flex;">
                            <div id="renderTarget" style="display:none;">
                                renderTarget:<br/>
                                <textarea id="txtValue" style="width:320px;height:240px;font-size:10px;"></textarea>
                            </div>
                            <div>
                                code:<br/>
                                <textarea id="txtScript" style="width:320px;height:240px;font-size:10px;"></textarea>
                            </div>
                        </div>
                        <div><button id="btnRun">run</button><button id="btnToogleRender">show render</button></div>
                    `);
                    function updateSources() {
                        for(var x = 0; x < track.data.live.length;x++) {
                            var item_layer = track.data.live[x];
                            for(var y = 0; y < self.app.video.layers.length;y++) {
                                if(self.app.video.layers[y].name == item_layer.name) {
                                    //console.log("UPDATE HTML");
                                    self.app.video.layers[y].update = true;
                                }
                            }
                        }
                    }
                    schema.el.txtValue.addEventListener("change",()=>{
                        track.data.value = schema.el.txtValue.value;
                    });
                    schema.el.txtValue.addEventListener("keyup",(e)=>{
                        track.data.value = schema.el.txtValue.value;
                        updateSources();
                    });
                    var renderVisible = false;
                    schema.el.btnToogleRender.addEventListener("click",()=>{
                        if(renderVisible) {
                            schema.el.renderTarget.style.display = "none";
                            schema.el.btnToogleRender.textContent = 'show render';
                            renderVisible = false;
                        } else {
                            schema.el.renderTarget.style.display = "";
                            schema.el.btnToogleRender.textContent = 'hide render';
                            renderVisible = true;
                        }
                    });
                    schema.el.btnRun.addEventListener("click",async function() {
                        
                        var code = `

                            function getLayers() {
                                var sel = [];
                                for(var y = 0; y < track.data.live.length;y++) {
                                    for(var x = 0; x < self.app.video.layers.length;x++) {
                                        var layer = self.app.video.layers[x];
                                        if(track.data.live[y].name == layer.name) {
                                            sel.push(layer);
                                            break;
                                        }
                                    }
                                }
                                return sel;
                            }
                            function target (src) {
                                console.log("TARGET");
                                schema.el.txtValue.value = src;
                                track.data.value = src;
                                updateSources();
                            }
                            {
                            let self = null;
                            let schema = null;
                            let track = null;
`;
                        code += schema.el.txtScript.value;
                        code += "}";
                        console.log("EVAL",code);
                        eval(code);
                        console.log("EVAL END");
                    });
                    function setHandler(schema,layer,x) {
                        schema.el["btnLayer_" + x].addEventListener("click",()=>{ // works like any pip layer
                            var found = false;
                            var sel_remove = [];
                            for(var y = 0; y < track.data.live.length;y++) {
                                if(track.data.live[y].name == layer.name) {
                                    found = true;
                                    layer.track = n;
                                    if(layer.track == n) { // on/off track
                                        layer.lastTrack = layer.track;
                                        layer.track = -1;

                                        sel_remove.push(y);
                                    } else {
                                        layer.lastTrack = layer.track;
                                        layer.track = n;
                                    }
                                    break;
                                }
                            }
                            for(var y = sel_remove.length-1;y>=0;y--) {
                                track.data.live.splice(sel_remove[y],1);
                            }
                            if(!found) {
                                track.data.live.push({name : layer.name });
                                layer.lastTrack = layer.track;
                                layer.track = n;
                            }
                            if(self.app.recordState == "stopped") {
                                recordHolder.el.style.display = "";
                            }
                            self.app.events.emit("layer_"+layer.name+"_hit",[n]);
                        });
                    }
                    for(var x = 0; x < self.app.video.layers.length;x++) {
                        var layer = self.app.video.layers[x];
                        setHandler(schema,layer,x);
                    }
                } else {
                    var schema = await tracksView.$.elementPushPacketAsync(`
                        <div style="display:flex;">
                            <div style="padding-left:5px;padding-right:5px;">🔊 ${(""+n).padStart(2,"0")}</div>
                            <div style="padding-left:5px;padding-right:5px;width:100px;overflow:hidden;white-space: nowrap;">${track.data.name}</div>
                            ${layerButtons}
                        </div>
                    `);
                    function setHandler(schema,layer,x) {
                        schema.el["btnLayer_" + x].addEventListener("click",()=>{ // works like any pip layer
                            layer.update = true;
                            var found = false;
                            var sel_remove = [];
                            for(var y = 0; y < track.data.live.length;y++) {
                                if(track.data.live[y].name == layer.name) {
                                    found = true;
                                    if(layer.track == n) { // on/off track
                                        //console.log("off n:",n);
                                        layer.lastTrack = layer.track;
                                        layer.track = -1;
                                        sel_remove.push(y);
                                    } else {
                                        //console.log("on");
                                        layer.lastTrack = layer.track;
                                        layer.track = n;
                                    }
                                    break;
                                }
                            }
                            for(var y = sel_remove.length-1;y>=0;y--) {
                                track.data.live.splice(sel_remove[y],1);
                            }
                            if(!found) {
                                //console.log("on 1");
                                track.data.live.push({name : layer.name });
                                layer.lastTrack = layer.track;
                                layer.track = n;
                            }
                            if(self.app.recordState == "stopped") {
                                recordHolder.el.style.display = "";
                            }
                            self.app.events.emit("layer_"+layer.name+"_hit",[n]);
                        });
                    }
                    for(var x = 0; x < self.app.video.layers.length;x++) {
                        var layer = self.app.video.layers[x];
                        setHandler(schema,layer,x);
                    }
                }
            } 
        }
    }

    if(self.app.tracks.length>0) lblTracks.el.style.display = "";
    else lblTracks.el.style.display = "none";
    for(var x =0; x < self.app.tracks.length;x++) {
        addTrack(x,self.app.tracks[x]);
    }

    if(self.app.hasVideoTracks() && !self.app.video.output.init) {
        self.app.video.output.init = true;
        //console.log("INIT VIDEO",self.app.hasVideoTracks(), self.app.video.output.init);
        recordHolder.el.style.display = "";
        var schema = await camera_holder.$.elementSetPacketAsync(`
            <div id="mockWidth"></div>
            <canvas id="videoOutput" style="border:solid 1px #000;background-color:#000;"></canvas>
            <video id="mockimg" style="display:none;"></video>
            <canvas id="videoOutputCopy" style="border:solid 1px #000;background-color:#000;display:none;"></canvas>
        `);
        var videoOutputSize = [parseInt(screenWidth.el.value),parseInt(screenHeight.el.value)];
        schema.el.videoOutput.setAttribute("width",videoOutputSize[0]);
        schema.el.videoOutput.setAttribute("height",videoOutputSize[1]);
        schema.el.videoOutput.style.backgroundColor = "black";

        schema.el.videoOutputCopy.setAttribute("width",videoOutputSize[0]);
        schema.el.videoOutputCopy.setAttribute("height",videoOutputSize[1]);

        if(videoOutputSize[0] < schema.el.mockWidth.offsetWidth) {
            if(videoOutputSize[1] > 480) {
                schema.el.videoOutput.style.height = '480px';
            } else {
                schema.el.videoOutput.style.width = videoOutputSize[0] + 'px';
            }
            
        } else {
            schema.el.videoOutput.style.width = "100%";
        }
        var pixi = self.app.video.pixi = new PIXI.Application({
            width: videoOutputSize[0], 
            height: videoOutputSize[1],
            transparent: true,
            view : schema.el.videoOutput
        });

        //var filter = new PIXI.filters.GodrayFilter();
        //console.log("FILTER",filter);
        //self.app.video.pixi.stage.filters = [filter];


        if(self.app.video.output.snapshot) {
            btnDownloadPicture.el.removeEventListener("click",self.app.video.output.snapshot);
        }
        self.app.video.output.snapshot = ()=>{
            const a = document.createElement('a');
            var url = self.app.video.pixi.renderer.plugins.extract.base64(	self.app.video.pixi.stage,"image/png");
            a.style.display = 'none';
            a.href = url;
            a.download = 'snapshot.png';
            document.body.appendChild(a);
            a.click();
            setTimeout(() => {
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
            }, 10000);
        };
        btnDownloadPicture.el.addEventListener("click",self.app.video.output.snapshot);


        self.app.video.canvasFlag = true;
        var lastTrack = -1;
        
        var first = true;
        self.app.video.outputLoop = async function() {
            if(!self.app.video.canvasFlag) return;

            if(first) {
                //console.log("output loop");
                first = false;
            }
            var msChanged = false;
            var update = false;
            for(var x =0; x < self.app.video.layers.length;x++) {
                var layer = self.app.video.layers[x];

                if(layer.update) {
                    update = true;
                } else if(update) {
                    layer.update = true;
                }
                self.app.events.emit("layer_"+layer.name+"_change",[{pixi:pixi,res:videoOutputSize}]);
            }
            setTimeout(()=>{
                self.app.video.outputLoop();
            },1000/60);
        };
        self.app.video.outputLoop();
        self.app.stream = stream = schema.el.videoOutput.captureStream(60);
        //schema.el.mockimg.srcObject = stream;
        //schema.el.mockimg.play();
        /*
        setInterval(async ()=>{
            if(chkExportOutput.el.checked) {
                const ctx = schema.el.videoOutputCopy.getContext('2d');
                ctx.clearRect(0, 0, videoOutputSize[0],videoOutputSize[1]);
                ctx.drawImage(schema.el.mockimg,0,0);
                //self.app.video.pixi.renderer.plugins.extract.canvas(self.app.video.pixi.stage).toBlob(function(blob) {
                  //  self.app.channel.postMessage({type:"stream",id:self.app.id,data:blob});
                //});
                schema.el.videoOutputCopy.toBlob(function(blob) {
                    self.app.channel.postMessage({type:"stream",id:self.app.id,data:blob});
                });
            }
        },1000/30);
        */
        self.app.video.mode = "play";

    } 
});
var clipNb = 0;
async function addAsset2(res) {

    var schema1 = await schema.$.list.elementUnshiftPacketAsync(`
        <tr style="cursor:pointer;">
            <td><span id="show">📼</span><span id="download">🔽</span><span id="addAsTrack">📌</span><span id="delete">❌</span></td>
            <td>${res[1].name} </td>
        </tr>
        <tr style="cursor:pointer;">
            <td colspan="2">
                <div>${res[1].comments}</div>
                <Component id="holder"></Component>
            </td>
        </tr>
    `);
    schema1.el.show.addEventListener("click",async ()=>{
        var s = await IDB.service(AssetSpec);
        var blob = await s.files.find(res[1].fileid);
        console.log(blob);
        var schema2 = await schema1.$.holder.elementSetPacketAsync(`
            <div>
                <video id="video" controls="true"></video>
            </div>
        `);
        schema2.el.video.src = window.URL.createObjectURL(blob);
        schema2.el.video.style.width = "100%";
        schema2.el.video.style.marginBottom = "-4px";
        schema2.el.video.play();

    });
    schema1.el.download.addEventListener("click",async ()=>{
        var s = await IDB.service(AssetSpec);
        var blob = await s.files.find(res[1].fileid);
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.style.display = 'none';
        a.href = url;
        a.download = 'last_record.webm';
        document.body.appendChild(a);
        a.click();
        setTimeout(() => {
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }, 10000);
    });
    schema1.el.addAsTrack.addEventListener("click",async ()=>{

        
        var s = await IDB.service(AssetSpec);
        var blob = await s.files.find(res[1].fileid);

        var videoel = document.createElement("video");
        var url = URL.createObjectURL(blob);
        videoel.src = url;

        //https://www.html5gamedevs.com/topic/43903-video-visible-size-is-empty/
        videoel.preload = 'auto';
        videoel.autoload = true;


        var stream = videoel.captureStream();//videoel.srcObject = await webm_blob.stream();
        var track = {
            type : "video",
            id : self.genId("TRACK0"),
            data : {
                name : "clip" + clipNb,
                type : "clip",
                stream : stream,
                el : videoel
            },
            events : []
        }
        clipNb++;
        self.app.tracks.push(track);
        self.app.events.emit("updateTracks");

    });
    schema1.el.delete.addEventListener("click",async ()=>{
        var filename = window.prompt("To delete, confirm filename:");
        if(filename == res[1].name) {
            var s = await IDB.service(AssetSpec);
            await s.files.delete(res[1].fileid);
            await s.files_meta.delete(res[0]);
            refresh_list();
        }

    });
}
async function addAsset(item) {
    

    var visible = false;
    var itemStruct = {
        init : false,
        data : item
    };
    var schema1 = await schema.$.list.elementUnshiftPacketAsync(`
        <tr style="cursor:pointer;">
            <td id="item">📼 ${item.id}</td>
            <td>🔽<a href="/messages/user1/${item.file}.ncp" download>download</a></td>
            <td id="addAsTrack">📌 add as track</td>
        </tr>
        <Component id="holder"></Component>
    `);
    itemStruct.schema1 = schema1;
    schema1.el.item.addEventListener("click",async ()=>{
        if(!visible) {
            if(!itemStruct.init) {
                itemStruct.init = true;
                var url = `/messages/user1/${item.file}.ncp`;

                var data = await fetch(url);
                var blob = await data.blob();
                var schema2 = await schema1.$.holder.elementPushPacketAsync(`
                    <tr id="view">
                        <td colspan="3" align="center">
                            <div>📅 ${item.date}</div>
                            <Component id="ncp" src="ncp.super" data={{this.src}}></Component>
                            <div id="sc"></div>
                        </td>
                    </tr>
                `,{context:{src:blob}});
                itemStruct.schema2 = schema2;
                schema2.el.sc.scrollIntoView({block:"center"});S
                schema2.exports.ncp.control.el.play();
                if( schema2.exports.ncp.spec.type == "audio.webm" ) {

                } else if(schema2.exports.ncp.spec.type == "video.webm") { // video tag, expecting bad margin, 100% width is custom
                    schema2.exports.ncp.control.el.style.width = "100%";
                    schema2.exports.ncp.control.el.style.marginBottom = "-7px";
                }
            } else {
                itemStruct.schema2.el.view.style.display = "";
                itemStruct.schema2.el.sc.scrollIntoView({block:"center"});
                itemStruct.schema2.exports.ncp.control.el.play();
            }
            
            visible = true;
        } else {
            itemStruct.schema2.el.view.style.display = "none";
            visible = false;
        }
    });
    
    schema1.el.addAsTrack.addEventListener("click",async ()=>{
        console.log("addAsTrack");
        var data = await fetch(`/messages/user1/${item.file}.ncp`);
        var blob = await data.blob();
        async function load() {

            var file_ab = await this.props.data.arrayBuffer();
            var br = new BinaryReader(this.props.data,file_ab);
            var sz = br.u32();
            var config_blob = br.toBlob(sz);
            var config_ab = await config_blob.arrayBuffer();
            var json_str = Binary.utf8ab2str(config_ab,config_ab.byteLength);
            this.spec = JSON.parse(json_str);

            // bound to 0.0.1
            if( this.spec.type == "audio.webm" ) {
                var sz2 = br.u32();
                var webm_blob = br.toBlob(sz2);
                // change by this point compared to control
                var arrayBuffer = await webm_blob.arrayBuffer();
                var audio = new AudioContext();
                var bufferSource = await audio.decodeAudioData(arrayBuffer);
                var track = {
                    type : "audio",
                    id : self.genId("TRACK0"),
                    data : {
                        mime : "application/ncp",
                        name : item.file + ".ncp",
                        audio : audio,
                        buffer : bufferSource
                    },
                    events : []
                };
                self.app.tracks.push(track);
                self.app.events.emit("updateTracks");
                //console.log(track);
            } else if(this.spec.type == "video.webm") {

                var sz2 = br.u32();
                var webm_blob = br.toBlob(sz2);

                var videoel = document.createElement("video");
                var url = URL.createObjectURL(webm_blob);
                videoel.src = url;
                videoel.play();
                var stream = videoel.captureStream();//videoel.srcObject = await webm_blob.stream();
                var track = {
                    type : "video",
                    id : self.genId("TRACK0"),
                    data : {
                        name : "clip" + clipNb,
                        type : "clip",
                        stream : stream,
                        el : videoel
                    },
                    events : []
                }
                clipNb++;
                self.app.tracks.push(track);
                self.app.events.emit("updateTracks");
                //console.log(track);
            }
            // end bound
        }
        load.apply({props:{data:blob}}); // to reuse this.zip same as ncp.super
    });
}
</script>
